name: App Build & Deploy (AKS)

on:
  pull_request:
    branches: [ main ]
    paths:
      - "app/**"
      - "Dockerfile"
      - ".github/workflows/app-build-and-deploy.yml"
  push:
    branches: [ main ]
    paths:
      - "app/**"
      - "Dockerfile"
      - ".github/workflows/app-build-and-deploy.yml"

permissions:
  id-token: write
  contents: read
  packages: write

env:
  IMAGE_NAME: remix-weather
  SHA_TAG: ${{ github.sha }}

jobs:
  build-and-push:
    name: Build & Push Image
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure OIDC Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ACR login
        run: az acr login --name "${{ vars.ACR_NAME }}"

      - name: Build & push (tag = SHA)
        run: |
          test -f Dockerfile || { echo "No Dockerfile in repo root"; exit 1; }
          docker build -f Dockerfile -t "${{ vars.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.SHA_TAG }}" .
          docker push "${{ vars.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.SHA_TAG }}"

      - name: Expose image ref
        id: meta
        run: echo "image=${{ vars.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.SHA_TAG }}" >> $GITHUB_OUTPUT

    outputs:
      image: ${{ steps.meta.outputs.image }}

  deploy-test:
    name: Deploy to AKS Test (PR only)
    if: github.event_name == 'pull_request'
    needs: build-and-push
    runs-on: ubuntu-latest
    environment:
      name: test
    env:
      IMAGE: ${{ needs.build-and-push.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install kubelogin
        uses: azure/use-kubelogin@v1
        with: { kubelogin-version: latest }
        env: { GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} }

      - name: AKS set-context (test)
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ vars.RESOURCE_GROUP }}
          cluster-name:  ${{ vars.AKS_TEST_NAME }}
          use-kubelogin: true

      - name: Create namespace if missing
        run: kubectl create namespace weather --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure weather-secret exists (test)
        run: |
          kubectl -n weather create secret generic weather-secret \
            --from-literal=WEATHER_API_KEY="${{ secrets.WEATHER_API_KEY }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply manifests (test)
        run: |
          sed "s|IMAGE_PLACEHOLDER|${IMAGE}|g" deployment.yaml | kubectl -n weather apply -f -
          kubectl -n weather apply -f service.yaml

      - name: Diagnose if not ready
        run: |
          set -x
          kubectl -n weather get deploy remix-weather-app -o wide || true
          kubectl -n weather get rs,pods -l app=remix-weather-app -o wide || true
          kubectl -n weather describe deploy remix-weather-app || true
          kubectl -n weather get events --sort-by=.lastTimestamp | tail -n 50 || true

      - name: Wait for rollout
        run: kubectl -n weather rollout status deploy/remix-weather-app --timeout=300s

  deploy-prod:
    name: Deploy to AKS Prod (on push to main)
    if: github.event_name == 'push'
    needs: build-and-push
    runs-on: ubuntu-latest
    environment:
      name: production
    env:
      IMAGE: ${{ needs.build-and-push.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install kubelogin
        uses: azure/use-kubelogin@v1
        with: { kubelogin-version: latest }
        env: { GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} }

      - name: AKS set-context (prod)
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ vars.RESOURCE_GROUP }}
          cluster-name:  ${{ vars.AKS_PROD_NAME }}
          use-kubelogin: true

      - name: Create namespace if missing
        run: kubectl create namespace weather --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure weather-secret exists (prod)
        run: |
          kubectl -n weather create secret generic weather-secret \
            --from-literal=WEATHER_API_KEY="${{ secrets.WEATHER_API_KEY }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply manifests (prod)
        run: |
          sed "s|IMAGE_PLACEHOLDER|${IMAGE}|g" deployment.yaml | kubectl -n weather apply -f -
          kubectl -n weather apply -f service.yaml

      - name: Diagnose if not ready
        run: |
          set -x
          kubectl -n weather get deploy remix-weather-app -o wide || true
          kubectl -n weather get rs,pods -l app=remix-weather-app -o wide || true
          kubectl -n weather describe deploy remix-weather-app || true
          kubectl -n weather get events --sort-by=.lastTimestamp | tail -n 50 || true

      - name: Wait for rollout
        run: kubectl -n weather rollout status deploy/remix-weather-app --timeout=300s
