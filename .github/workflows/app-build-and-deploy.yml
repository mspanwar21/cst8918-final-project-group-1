name: App Build & Deploy (AKS)

on:
  pull_request:
    branches: [ main ]
    paths:
      - "app/**"
      - "Dockerfile"
      - ".github/workflows/app-build-and-deploy.yml"
  push:
    branches: [ main ]
    paths:
      - "app/**"
      - "Dockerfile"
      - ".github/workflows/app-build-and-deploy.yml"

permissions:
  id-token: write
  contents: read
  packages: write

env:
  IMAGE_NAME: remix-weather
  SHA_TAG: ${{ github.sha }}

jobs:
  build-and-push:
    name: Build & Push Image
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.meta.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure OIDC Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ACR login
        run: az acr login --name "${{ vars.ACR_NAME }}"

      - name: Build & push (tag = SHA)
        run: |
          test -f Dockerfile || { echo "No Dockerfile in repo root"; exit 1; }
          docker build -f Dockerfile -t "${{ vars.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.SHA_TAG }}" .
          docker push "${{ vars.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.SHA_TAG }}"

      - name: Expose image ref
        id: meta
        run: echo "image=${{ vars.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.SHA_TAG }}" >> $GITHUB_OUTPUT

  deploy-test:
    name: Deploy to AKS Test (PR only)
    if: github.event_name == 'pull_request'
    needs: build-and-push
    runs-on: ubuntu-latest
    environment:
      name: test
    env:
      IMAGE: ${{ needs.build-and-push.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install kubelogin
        uses: azure/use-kubelogin@v1
        with:
          kubelogin-version: latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: AKS set-context (test)
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ vars.RESOURCE_GROUP }}
          cluster-name: ${{ vars.AKS_TEST_NAME }}
          use-kubelogin: true

      - name: Create namespace if missing
        run: kubectl create namespace weather --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure weather-secret exists (test)
        run: |
          kubectl -n weather create secret generic weather-secret \
            --from-literal=WEATHER_API_KEY="${{ secrets.WEATHER_API_KEY }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Verify image exists in ACR
        run: |
          az acr repository show-tags -n "${{ vars.ACR_NAME }}" --repository "${{ env.IMAGE_NAME }}" \
            | grep -q "${{ env.SHA_TAG }}" \
            || { echo "Tag not found in ACR: ${{ env.SHA_TAG }}"; exit 1; }

      - name: Apply manifests (test)
        run: |
          # Apply manifests (sed works if your deployment.yaml uses IMAGE_PLACEHOLDER)
          sed "s|IMAGE_PLACEHOLDER|${IMAGE}|g" deployment.yaml | kubectl -n weather apply -f -
          kubectl -n weather apply -f service.yaml
          # Regardless of sed, force the Deployment to use the new image:
          kubectl -n weather set image deploy/remix-weather-app remix-weather="${IMAGE}" --record

      - name: Diagnose rollout (test)
        run: |
          set -x
          echo "=== Deployment ==="
          kubectl -n weather get deploy remix-weather-app -o wide || true
          kubectl -n weather describe deploy remix-weather-app || true
          echo "=== ReplicaSets & Pods ==="
          kubectl -n weather get rs -l app=remix-weather-app -o wide || true
          kubectl -n weather get pods -l app=remix-weather-app -o wide || true
          echo "=== Recent Events ==="
          kubectl -n weather get events --sort-by=.lastTimestamp | tail -n 50 || true
          echo "=== Pod logs (first pod) ==="
          POD=$(kubectl -n weather get pods -l app=remix-weather-app -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
          if [ -n "$POD" ]; then kubectl -n weather logs "$POD" --all-containers=true || true; fi

      - name: Wait for rollout
        run: kubectl -n weather rollout status deploy/remix-weather-app --timeout=300s

  deploy-prod:
    name: Deploy to AKS Prod (on push to main)
    if: github.event_name == 'push'
    needs: build-and-push
    runs-on: ubuntu-latest
    environment:
      name: production
    env:
      IMAGE: ${{ needs.build-and-push.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install kubelogin
        uses: azure/use-kubelogin@v1
        with:
          kubelogin-version: latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: AKS set-context (prod)
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ vars.RESOURCE_GROUP }}
          cluster-name: ${{ vars.AKS_PROD_NAME }}
          use-kubelogin: true

      - name: Create namespace if missing
        run: kubectl create namespace weather --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure weather-secret exists (prod)
        run: |
          kubectl -n weather create secret generic weather-secret \
            --from-literal=WEATHER_API_KEY="${{ secrets.WEATHER_API_KEY }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Verify image exists in ACR
        run: |
          az acr repository show-tags -n "${{ vars.ACR_NAME }}" --repository "${{ env.IMAGE_NAME }}" \
            | grep -q "${{ env.SHA_TAG }}" \
            || { echo "Tag not found in ACR: ${{ env.SHA_TAG }}"; exit 1; }

      - name: Apply manifests (prod)
        run: |
          sed "s|IMAGE_PLACEHOLDER|${IMAGE}|g" deployment.yaml | kubectl -n weather apply -f -
          kubectl -n weather apply -f service.yaml
          kubectl -n weather set image deploy/remix-weather-app remix-weather="${IMAGE}" --record

      - name: Diagnose rollout (prod)
        run: |
          set -x
          echo "=== Deployment ==="
          kubectl -n weather get deploy remix-weather-app -o wide || true
          kubectl -n weather describe deploy remix-weather-app || true
          echo "=== ReplicaSets & Pods ==="
          kubectl -n weather get rs -l app=remix-weather-app -o wide || true
          kubectl -n weather get pods -l app=remix-weather-app -o wide || true
          echo "=== Recent Events ==="
          kubectl -n weather get events --sort-by=.lastTimestamp | tail -n 50 || true
          echo "=== Pod logs (first pod) ==="
          POD=$(kubectl -n weather get pods -l app=remix-weather-app -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
          if [ -n "$POD" ]; then kubectl -n weather logs "$POD" --all-containers=true || true; fi

      - name: Wait for rollout
        run: kubectl -n weather rollout status deploy/remix-weather-app --timeout=300s
