name: App Build & Deploy (AKS)

on:
  pull_request:
    branches: [ main ]
    paths:
      - "app/**"
      - "Dockerfile"
      - ".github/workflows/app-build-and-deploy.yml"
  push:
    branches: [ main ]
    paths:
      - "app/**"
      - "Dockerfile"
      - ".github/workflows/app-build-and-deploy.yml"

permissions:
  id-token: write
  contents: read
  packages: write

env:
  IMAGE_NAME: remix-weather
  SHA_TAG: ${{ github.sha }}

jobs:
  build-and-push:
    name: Build & Push Image
    if: github.event_name == 'pull_request' || github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.meta.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure OIDC Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ACR login
        run: az acr login --name "${{ vars.ACR_NAME }}"

      - name: Build & push (tag = SHA)
        run: |
          test -f Dockerfile || { echo "No Dockerfile in repo root"; exit 1; }
          docker build -f Dockerfile -t "${{ vars.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.SHA_TAG }}" .
          docker push "${{ vars.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.SHA_TAG }}"

      - name: Expose image ref
        id: meta
        run: echo "image=${{ vars.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ env.SHA_TAG }}" >> $GITHUB_OUTPUT

  deploy-test:
    name: Deploy to AKS Test (PR only)
    if: github.event_name == 'pull_request'
    needs: build-and-push
    runs-on: ubuntu-latest
    environment:
      name: test
    env:
      IMAGE: ${{ needs.build-and-push.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install kubelogin
        uses: azure/use-kubelogin@v1
        with:
          kubelogin-version: latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: AKS set-context (test)
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ vars.RESOURCE_GROUP }}
          cluster-name: ${{ vars.AKS_TEST_NAME }}
          use-kubelogin: true

      - name: Create namespace if missing
        run: kubectl create namespace weather --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure weather-secret exists (test)
        run: |
          kubectl -n weather create secret generic weather-secret \
            --from-literal=WEATHER_API_KEY="${{ secrets.WEATHER_API_KEY }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Verify image exists in ACR
        run: |
          az acr repository show-tags -n "${{ vars.ACR_NAME }}" --repository "${{ env.IMAGE_NAME }}" \
            | grep -q "${{ env.SHA_TAG }}" \
            || { echo "Tag not found in ACR: ${{ env.SHA_TAG }}"; exit 1; }

      # ==== SMART SKIP / WARN-ONLY ROLLOUT ====
      - name: Check if deployment needs update
        id: diff
        run: |
          set -e
          if kubectl -n weather get deploy remix-weather-app >/dev/null 2>&1; then
            CUR=$(kubectl -n weather get deploy remix-weather-app -o jsonpath='{.spec.template.spec.containers[?(@.name=="remix-weather")].image}')
            echo "Current image: ${CUR}"
            if [ "$CUR" = "${IMAGE}" ]; then
              echo "needs_update=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          echo "needs_update=true" >> $GITHUB_OUTPUT

      - name: Apply manifests (test)
        if: steps.diff.outputs.needs_update == 'true'
        run: |
          sed "s|IMAGE_PLACEHOLDER|${IMAGE}|g" deployment.yaml | kubectl -n weather apply -f -
          kubectl -n weather apply -f service.yaml
          kubectl -n weather set image deploy/remix-weather-app remix-weather="${IMAGE}" --record

      - name: Diagnose rollout (test)
        if: steps.diff.outputs.needs_update == 'true'
        run: |
          set -x
          kubectl -n weather get deploy remix-weather-app -o wide || true
          kubectl -n weather get rs -l app=remix-weather-app -o wide || true
          kubectl -n weather get pods -l app=remix-weather-app -o wide || true
          kubectl -n weather get events --sort-by=.lastTimestamp | tail -n 50 || true

      - name: Wait for rollout (warn-only)
        if: steps.diff.outputs.needs_update == 'true'
        id: wait
        continue-on-error: true
        run: kubectl -n weather rollout status deploy/remix-weather-app --timeout=180s

      - name: Note skipped or long rollout
        if: steps.diff.outputs.needs_update != 'true' || steps.wait.outcome == 'failure'
        run: |
          if [ "${{ steps.diff.outputs.needs_update }}" != "true" ]; then
            echo "::warning::Deploy skipped: image already up to date (${IMAGE})."
          else
            echo "::warning::Rollout did not finish within timeout; proceeding."
          fi
      # ==== END SMART SKIP ====

  deploy-prod:
    name: Deploy to AKS Prod (on push to main)
    if: github.event_name == 'push'
    needs: build-and-push
    runs-on: ubuntu-latest
    environment:
      name: production
    env:
      IMAGE: ${{ needs.build-and-push.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install kubelogin
        uses: azure/use-kubelogin@v1
        with:
          kubelogin-version: latest
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: AKS set-context (prod)
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ vars.RESOURCE_GROUP }}
          cluster-name: ${{ vars.AKS_PROD_NAME }}
          use-kubelogin: true

      - name: Create namespace if missing
        run: kubectl create namespace weather --dry-run=client -o yaml | kubectl apply -f -

      - name: Ensure weather-secret exists (prod)
        run: |
          kubectl -n weather create secret generic weather-secret \
            --from-literal=WEATHER_API_KEY="${{ secrets.WEATHER_API_KEY }}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Verify image exists in ACR
        run: |
          az acr repository show-tags -n "${{ vars.ACR_NAME }}" --repository "${{ env.IMAGE_NAME }}" \
            | grep -q "${{ env.SHA_TAG }}" \
            || { echo "Tag not found in ACR: ${{ env.SHA_TAG }}"; exit 1; }

      # ==== SMART SKIP / WARN-ONLY ROLLOUT ====
      - name: Check if deployment needs update
        id: diff
        run: |
          set -e
          if kubectl -n weather get deploy remix-weather-app >/dev/null 2>&1; then
            CUR=$(kubectl -n weather get deploy remix-weather-app -o jsonpath='{.spec.template.spec.containers[?(@.name=="remix-weather")].image}')
            echo "Current image: ${CUR}"
            if [ "$CUR" = "${IMAGE}" ]; then
              echo "needs_update=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          echo "needs_update=true" >> $GITHUB_OUTPUT

      - name: Apply manifests (prod)
        if: steps.diff.outputs.needs_update == 'true'
        run: |
          sed "s|IMAGE_PLACEHOLDER|${IMAGE}|g" deployment.yaml | kubectl -n weather apply -f -
          kubectl -n weather apply -f service.yaml
          kubectl -n weather set image deploy/remix-weather-app remix-weather="${IMAGE}" --record

      - name: Diagnose rollout (prod)
        if: steps.diff.outputs.needs_update == 'true'
        run: |
          set -x
          kubectl -n weather get deploy remix-weather-app -o wide || true
          kubectl -n weather get rs -l app=remix-weather-app -o wide || true
          kubectl -n weather get pods -l app=remix-weather-app -o wide || true
          kubectl -n weather get events --sort-by=.lastTimestamp | tail -n 50 || true

      - name: Wait for rollout (warn-only)
        if: steps.diff.outputs.needs_update == 'true'
        id: wait
        continue-on-error: true
        run: kubectl -n weather rollout status deploy/remix-weather-app --timeout=180s

      - name: Note skipped or long rollout
        if: steps.diff.outputs.needs_update != 'true' || steps.wait.outcome == 'failure'
        run: |
          if [ "${{ steps.diff.outputs.needs_update }}" != "true" ]; then
            echo "::warning::Deploy skipped: image already up to date (${IMAGE})."
          else
            echo "::warning::Rollout did not finish within timeout; proceeding."
          fi
      # ==== END SMART SKIP ====
